#include <iostream>  // Подключение библиотеки для ввода-вывода
#include <vector>    // Подключение библиотеки для работы с векторами
#include <algorithm> // Подключение библиотеки для стандартных алгоритмов, таких как count

using namespace std; // Использование пространства имен std для упрощения кода

// Функция для подсчета минимального количества перестановок, чтобы отсортировать массив
int minSwapsToSort(vector<int>& arr) {
    int n = arr.size(); // Определение размера массива

    // Подсчет количества элементов `1`, `2` и `3` в массиве
    int count1 = count(arr.begin(), arr.end(), 1);
    int count2 = count(arr.begin(), arr.end(), 2);
    int count3 = n - count1 - count2; // Остальные элементы считаются как `3`

    // Инициализация переменных для подсчета неправильных позиций (несоответствий) между различными типами
    int misplace12 = 0, misplace13 = 0, misplace21 = 0, misplace23 = 0, misplace31 = 0, misplace32 = 0;

    // Подсчет количества элементов `2` и `3`, находящихся в первом сегменте массива (где должны быть `1`)
    for (int i = 0; i < count1; ++i) {
        if (arr[i] == 2) ++misplace21; // Подсчет `2`, которые стоят в зоне `1`
        if (arr[i] == 3) ++misplace31; // Подсчет `3`, которые стоят в зоне `1`
    }

    // Подсчет количества элементов `1` и `3`, находящихся во втором сегменте массива (где должны быть `2`)
    for (int i = count1; i < count1 + count2; ++i) {
        if (arr[i] == 1) ++misplace12; // Подсчет `1`, которые стоят в зоне `2`
        if (arr[i] == 3) ++misplace32; // Подсчет `3`, которые стоят в зоне `2`
    }

    // Подсчет количества элементов `1` и `2`, находящихся в третьем сегменте массива (где должны быть `3`)
    for (int i = count1 + count2; i < n; ++i) {
        if (arr[i] == 1) ++misplace13; // Подсчет `1`, которые стоят в зоне `3`
        if (arr[i] == 2) ++misplace23; // Подсчет `2`, которые стоят в зоне `3`
    }

    // Подсчет количества минимальных прямых обменов между несоответствующими парами
    int swaps = min(misplace12, misplace21) + min(misplace13, misplace31) + min(misplace23, misplace32);

    // Подсчет оставшихся несоответствий после прямых обменов
    int remaining = abs(misplace12 - misplace21) + abs(misplace13 - misplace31) + abs(misplace23 - misplace32);
    swaps += remaining / 3 * 2; // 

    return swaps; // Возвращаем итоговое количество минимальных перестановок
}

int main() {
    int n; // Объявление переменной для размера массива
    cin >> n; // Чтение размера массива с ввода
    vector<int> arr(n); // Создание вектора размером `n`
    for (int i = 0; i < n; ++i) {
        cin >> arr[i]; // Чтение элементов массива с ввода
    }

    int result = minSwapsToSort(arr); // Вызов функции для вычисления минимального количества перестановок
    cout << result << endl; // Вывод результата 

    return 0; // Завершение программы
}